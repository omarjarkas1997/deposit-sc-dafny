# Library for hashing
from hashlib import blake2s
import binascii

# when hash(something) is called this means to hash it using this standard blake2s(x).digest()
def hash(x): return blake2s(x).digest()

# in ethereum an address in 32 bytes
# each bit is made up 2 hexademical representation
# [b'\x00' * 32] <==> [b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00']
# which is equivalent to         0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX --- 64 hexadecimals
zerohashes = [b'\x00' * 32] ##   0x0000000000000000000000000000000000000000000000000000000000000000 --- 64 hexadecimal



# what does this for loop do
# given the zerohashes list above it take it as an inital value and appending to the list the hash(0000 * 8 ,0000 * 8) 
# suppose it gives 4F67 * 8, it appends to the list the hash(4F67 * 8, 4F67 * 8)
# # this is repeated 31 times until we have an array of 32 address in the zerohashes list
# [b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', b'\xae\t\xdb|\xd5OB\xb4\x90\xef\t\xb6\xbcT\x1a\xf6\x88\xe4\x95\x9b\xb8\xc5?5\x9aoV\xe3\x8a\xb4T\xa3', b'\xda\x86X\x00\x85bc\xc1B\xa8\xad\x1c\x03<\x97^\x0cFr\x82\xf6\xddf\x87\xe73`\x1d\xf8qcM', b'\xc2U_\x92\xcb\xe5Z(\x07\xbb\xe1\xb9\x96\\.tec\x0c\xa5\xd1\x1b\x150\xec\xd0\xe6\xe3\xe2\xcdw\xa2', b'\xa0g\xcd\xc8bC`\x04\x95\xb0\xf5\x1c\xc9\t=\r,\xed\x05\x96\xaaA\x97\xe8"\xe8\xea\x12\xa6\x15I\x8b', b'\xfc\x1e\xdc\x07t\xf3\x97\xdb\xabg\xb9\x02\x9d\xf6\x9c\xaaz\xad\xd9^\xb3$\x02_k\x851\x9d1\x83\xb5|', b"\x90-\x02\xe7\x9a\xde\x9b\x10\xa0p\xf9@\x86{H\x17\xc2\x1a\n\x94\xd5\xbb/\xe74\x04vyf\x89\xeb'", b'=\xba\xc2\x16\xc1\xed\xee\xad|\xd7\x15\x835\xbd\x0b\xd9\x92L4R\xa2s\xda!\xe9\xba[\xbe`\xe1\xd9\x87', b'k\xc6I,\x8cM%A\xf2\x81\x91\r\xe7\x9f8\xab%g\xccn\x11[\xb3\xa2\xb3)\x07Q\x19P\xb6V', b'\xec\x1f7*3v\x1a#\xa4%9\x03\x19\xa5\xc3\xee\xee\x91\t\x9f\x8c\xba\xd8\xe9\x8f%-\xfd\xc4\x18\x15\r', b'\rw\x80\x0f\x99NN`\xf9\xc2y\x8d\xc1\xb1\x1c\xd3\x9f\x0fI\xa6\x01\x9f\xb4\xe3\x87-\xc6I\xa6\xdfr\xa5', b'}\n\xf7(\xf6\x96\xab\x08;\xd4[\xe6\xfb\xa4\xf6\xb13\x1b\xfb2~+\xda\xe0\xd1)\xa7\x84\xdc\xd3@\x0f', b'\x07\xc5\xd7m\x04>.\x1f\\\xde\xa83\x03\x0c\x08C\xea\xdb\xf2\n\xe3x\x9e\x11\xa4I\xab\xf2\x1b5\xd9\xff', b'\xaf7Y\xc5\x9a7\xbd\x1f\x7f\x01"KX\x9c\xbb\t\xe0\x93O\xda@\xb6\xfc\x0eE\xf6\x84\x97\n\xf0r\x7f', b'\x07<\xdd&\xd1\xe5\xb1\xbe\x97+\x1bl\xe3mJ\x12+\xa7\xa5\x1d\xbf\xa6\xd6\xd0>\x05`\xc1\x12\xb8gN', b'\x08!@\xd1&\xb1f\xb1\xb3\xc8yB\xb9S\xef#"f\xf6\xebX!\n^\x9d\xbe\xc4#\x1d\x9aCM', b'u\x89\x85\xd21\x82f\xc2\x01Y\xdd7\xf9\xedl\xfes7\x0f\x93G,\xa3\x1c\xb4R\xdfW\xd5\x98gd', b'w2Y\x1aQ\xc8\xfaz~(\x1d\xb8\x18=Q\x84\x11\x17\xc0Y\x98\x83\xea\x02,\xbco\xd0>bl1', b'i\x00\xaf\xb5&\xb3\x9b\x1eJ\n_\xbc\x92\xf1\xd7\xfb\xe6\x84\xd0V\xc4\xdfm\xe1\xeb/\x9cO\x04g\x1b\x97', b'ITv\xef\xb9K"\xf2\xdcH\xe2I\xe7\xbe\x15\xaf}\x85\x1bj\xfd\x92\xf5Fd\xab\xd5\xd11[]\x0b', b'b\xeb\xdb\x87\xff\xe3\xcdPw\xfcKcZ\xd2\xa1|=\x14\xf4\xe8\xb6N\xc1O\x07-\x82Z\xf2h\xa7B', b'R\xf4\x8c\xe5A\x9d\xafV\xab0\x08\xd6\r:\xe1}\xea=\xd1\xca\xb9mvp9)\xcfl@\x1f\xfb\xe6', b'\x8d\xedI\xc0\x97\x8d\xd63)L\xf4D\n\xa7:\xec\xfc\xc9\xdd\x150\xbbWY\x95\xe5?\x16\xe3\xc8\x10T', b"\xbb\x10x\xe8u\x84\xe2\x9f\x98\xa0T\x03\x91@\x89\x16d\xd6\x8f/\xfb \xcc\xdbLG\x06cD'K\x93", b'\xdc\xf4sh<\xfd\xb9o4\xeeD,\x86g\x17\x8f\xcd3\x1fv\x82\xd7\x9c\nA\xb0e\x01\n\xcd\xbc\x84', 
# b'\r\xa4Q\xc7\x83o\xe4\xc1$\xd1&\xe9\xc6Nu\xb5\xb8S\xd9\xe8\x9a\x0f\xaf*\x81\xde5\x02\xb5p\x88\xb2', b"S\x9d\xc1\x08\xfbj\xdf\xfd\r\x89\xc4\x9bL5SO\xd4\x9d\x17\r\xfb'\x82\n/\x06\xfe\xba\x1d\xf6\xdc\xc5", b';\xde\x1a4\xea\x83\xa0-\xd4\xd4y\xfbg\x86\xa9ZiKPA`\xac#\x9a\xb3Q ;\xe1o\xfb\n', b'k\x9bG\xa3\xf1i\xee\xb7\xd0"\x0b\xb0\x16\x8a\xe90\xc3\x86j\x14{\xd0\x10\xf4d\xa3\xc9\xfb\x01\x9a\xf9F', b'PH\xa0\x937\x8d\xbe\x12\xeb\xf7\xa5\xaa\x97i\xfd\x05O\xa5\x11\xc8K\xd4\x88\xba\x14g\x0fm\xc9i\xd5\xad', b'\x83\x83\xd8\x92\x1f\x83\xfa\xb3N]\x8dZ\x0f\x1e\xb0\xfcS\xae\x18W\xed\r\x9a\xf5\xc5B\xe3\xf8\x7f5L\xb1', b'\x92\xbc\x8b\xc8\xa5\xb9k\xd3\xca&\x13\xe3"e\x86\x96V\x899\x9c\x9a\xfd\x84(\xf4\xeb\x92\xc9\xc8A\x1a\x8b']
# the above is an array of 32 address form be hashing the last element in the array and adding the result to the same array 
for i in range(1, 32):
    zerohashes.append(hash(zerohashes[i-1] + zerohashes[i-1]))

# Add a value to a Merkle tree by using the algo
# that stores a branch of sub-roots
def add_value(branch, index, value):
    i = 0
    while (index+1) % 2**(i+1) == 0:
        i += 1
    for j in range(0, i):
        value = hash(branch[j] + value)
        # branch[j] = zerohashes[j]
    branch[i] = value

# Compute a Merkle root the dumb way
def merkle_root(values):
    for h in range(32): # from 0 to 31
        if len(values) % 2 == 1: 
            values.append(zerohashes[h])
        values = [hash(values[i] + values[i+1]) for i in range(0, len(values), 2)]
    return values[0]

def get_root_from_branch(branch, size):
    r = b'\x00' * 32
    for h in range(32):
        if (size >> h) % 2 == 1:
            r = hash(branch[h] + r)
        else:
            r = hash(r + zerohashes[h])
    return r

def branch_by_branch(values):
    branch = zerohashes[::]
    # Construct the tree using the branch-based algo
    for index, value in enumerate(values):
        add_value(branch, index, value)
    # Return the root
    return get_root_from_branch(branch, len(values))

testdata = [(i + 2**255).to_bytes(32, 'big') for i in range(10000)]

# The Merkle root algo assumes trailing zero bytes
assert merkle_root(testdata[:5]) == merkle_root(testdata[:5] + [b'\x00' * 32] * 5)

# Verify equivalence of the simple all-at-once method and the progressive method
assert branch_by_branch(testdata[:1]) == merkle_root(testdata[:1])
assert branch_by_branch(testdata[:2]) == merkle_root(testdata[:2])
assert branch_by_branch(testdata[:3]) == merkle_root(testdata[:3])
assert branch_by_branch(testdata[:5049]) == merkle_root(testdata[:5049])